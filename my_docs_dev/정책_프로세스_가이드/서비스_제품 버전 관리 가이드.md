# 서비스/제품 버전 관리 가이드 (v1.0)

## 문서 목적

이 문서는 서비스 및 제품의 버전 관리 원칙과 규칙을 명확히 정의하여, 버전 명명·증가·운영 과정에서 혼선을 줄이고, 모든 관련자가 일관된 기준에 따라 버전을 관리할 수 있도록 하는 것을 목적으로 합니다. 특히 Major/Minor/Patch/Level/Build Number 구분, Jira/Git/CI-CD와의 연계, 테스트 비중 차이를 명확히 하여 실무에 즉시 활용할 수 있는 기준을 제공합니다.

## 1. 버전 구성 요소 정의

- **Major (X.0.0)**: 서비스/제품의 대규모 변경을 반영하는 단계. 단순히 API 호환성 깨짐뿐 아니라 **신규 서비스/기능군 추가, UX/UI 전면 개편, 데이터 구조 변경 등 사용자 경험과 운영 전반에 큰 영향을 미치는 경우**를 포함함.
- **Minor (0.Y.0)**: 기존 기능과 호환 가능한 신규 기능 추가, 성능 개선, 일부 기능 확장
- **Patch (0.0.Z)**: 버그 수정, 보안 패치, 긴급 수정 등
- **Level (alpha/beta/rc)**: 동일 Major.Minor.Patch 내에서 배포 준비도를 나타내는 사전 릴리즈 단계
  - Alpha: 내부 검증 단계 (개발팀, 내부 QA)
  - Beta: 일부 사용자 대상으로 검증 (Closed/Open Beta)
  - RC(Release Candidate): 정식 배포 직전 최종 후보 버전
- **Build Number (+N)**: 버전과 무관하게 절대 리셋되지 않고 계속 증가하는 빌드 일련번호
  - 앱: 스토어 심사 대응, 빌드 재제출 시 필수 증가 (이전 빌드보다 항상 높아야 함)
  - 웹: 선택적 사용 (CI/CD 파이프라인 추적용)
  - 예: 6.0.2-alpha.1+1003 → 6.0.2-beta.1+1004 → 6.1.0-rc.1+1005 (버전 변경과 무관하게 단조 증가)

### 네이밍 규칙 예시

- `version: 6.0.2-alpha.1+1003` (앱)
- `version: 6.0.2-alpha.1` (웹)
- `version: 6.0.2-beta.2+1004`
- `version: 6.0.2-rc.1+1005`
- **형식**: `major.minor.patch-level+buildNumber`

## 2. 버전 증가 기준

- **Major**: 대규모 변경(신규 서비스군, UX/UI 전면 개편, API 호환성 깨짐, 데이터 구조 변경 등)
- **Minor**: 새로운 기능 추가, 성능 개선, 일부 확장
- **Patch**: 정기 배포, 버그/보안 수정, 긴급 수정
- **Level/Build Number**: QA 사이클 및 빌드 배포 시 자동 증가

## 3. 버전 결정 프로세스 개요

버전 결정은 변경 범위와 영향도에 따라 다른 승인 프로세스를 거칩니다. (상세 내용은 16번 섹션 참조)

- **Major 버전**: 경영진·기획·개발 합의 필요, 개발계획서 필수
- **Minor 버전**: PL 주도, 개발 책임자 검토
- **Patch 버전**: PL 승인
- **Level/Build 번호**: QA·CI/CD 자동화 관리

## 4. 버전 결정 시 고려 요소

- 변경 범위와 영향도 (UX, API 호환성, 신규 기능군, 데이터 구조 변경)
- QA 및 테스트 범위 (Major > Minor > Patch 순)
- App 심사/의료·보안 인증 이슈 등 외부 요인
- 사용자 공지 및 릴리즈 노트 필요성

## 5. 하위 호환성 정책

- **Major 버전**: 하위 호환성을 보장하지 않음 (Breaking Changes 허용)
- **Minor 버전**: 하위 호환성 유지 필수 (기존 기능 동작 보장)
- **Patch 버전**: 하위 호환성 완전 보장 (버그 수정만 포함)
- **Breaking Changes 처리**:
  - Major 변경 시에만 허용
  - 개발계획서에 명시 및 사전 공지 필수
  - 가능한 경우 Deprecation Warning 먼저 배포 후 다음 Major에서 제거
- **Deprecation 정책**:
  - 기능 제거 최소 1개 Major 버전 전에 Deprecated 선언
  - 릴리즈 노트 및 API 문서에 대체 방법 명시

## 6. 서버·서비스·앱 버전 일치 규칙

- 서버와 앱 간 API 호환성을 유지하기 위해 최소한 **Major/Minor는 일치**시켜야 함
- Patch는 독립적으로 관리 가능 (단, 반드시 호환성 체크 필요)
- **플랫폼별 독립 배포 시나리오**:
  - iOS 심사 지연 등으로 플랫폼별 배포 시점이 다른 경우, 서버는 양쪽 버전 모두 지원해야 함
  - 예: Android 6.1.0 배포 완료, iOS 6.0.5 심사 중 → 서버는 6.0.x와 6.1.x API 모두 지원
- **최소 지원 버전 정책**:
  - 서버는 최소 2개 Major 버전까지 하위 호환성 유지 권장
  - 클라이언트 최소 지원 OS 버전 변경 시 Minor 또는 Major 버전 증가
- **버전 호환성 매트릭스**: 프로젝트별로 서버-클라이언트 호환성 표 관리 권장

## 7. Hotfix 정책

- **Hotfix 정의**: 프로덕션 환경에서 발생한 긴급 문제(크리티컬 버그, 보안 이슈 등)를 신속히 수정하는 배포
- **버전 증가 규칙**: Hotfix는 **Patch 버전을 증가**시킴
  - 예: 6.1.2 배포 후 긴급 수정 발생 → 6.1.3 배포
- **브랜치 전략**:
  - `main` 브랜치에서 `hotfix/` 브랜치 생성
  - 수정 완료 후 `main`에 머지 및 배포
  - **반드시 `develop` 브랜치로도 머지**하여 동기화 유지
- **승인 프로세스**: 긴급 상황이므로 PL 또는 개발 책임자 승인으로 즉시 배포 가능
- **테스트 범위**: 수정된 부분 + Smoke Test (최소한의 검증)

## 8. 사전 릴리즈 및 정식 배포

- **정식 배포 기준**: RC 테스트에서 Critical/Major 이슈 0건 확인 후 배포
- **RC가 정식 버전이 되는 과정**:
  - 앱: `6.0.2-rc.1+1005`로 스토어 심사 제출 → 심사 통과 시 **그대로 `6.0.2-rc.1+1005`가 정식 버전**
  - 웹: RC 테스트 완료 후 **Level 표기를 제거한 `6.0.2`로 프로덕션 배포** 가능
  - 주의: 이미 스토어에 제출된 앱은 버전 번호를 바꿀 수 없음
- **RC에서 문제 발견 시**:
  - 수정 후 같은 버전의 새로운 RC 생성 (예: `6.0.2-rc.1+1005` → `6.0.2-rc.2+1006`)
  - RC 단계는 정식 배포 전이므로 Patch를 올리지 않고 RC 번호만 증가
- **테스트 중 기능 제거/변경 시**:
  - Minor 기능이 제거된 경우: 해당 버전에서 제외하고 배포
  - Major 수준 변경이 필요한 경우: 새로운 버전 사이클 시작 (예: 6.1.0 또는 7.0.0)

## 9. 롤백 정책

- **롤백 시나리오**: 배포 후 Critical 이슈 발견 시 즉시 이전 버전으로 복구
- **롤백 후 버전 처리**:
  - 롤백은 버전을 되돌리는 것 (예: 6.0.2 → 6.0.1로 복구)
  - 수정 후 재배포 시 **새로운 Patch 버전 사용** (예: 6.0.3)
  - 동일 버전 번호로 재배포 금지 (추적 및 캐싱 문제 방지)
- **롤백 결정 권한**: PL, 개발 책임자 또는 긴급 상황 시 운영 책임자
- **롤백 후 조치**:
  - 원인 분석 및 사고 보고서 작성
  - 재발 방지 대책 수립 및 공유

## 10. Jira와 버전 관리

- **Jira Version(Release/FixVersion)**: `major.minor.patch`만 사용합니다. Level(`alpha/beta/rc`)과 Build Number는 포함하지 않습니다.
- 필요 시 이슈 라벨이나 커스텀 필드로 Level을 병기합니다. 예) `release:alpha.1`, `release:rc.1`.
- PL(Project Lead)이 Jira 버전 생성·마감과 이슈 매핑을 최종 확인합니다.

## 11. 테스트 비중 가이드

- **Major 버전**: 전체 Regression, 부하/성능 테스트, 보안 검증 포함 (Full Scope)
- **Minor 버전**: 신규 기능/변경 영역 집중 + 핵심 Regression
- **Patch 버전**: 수정된 기능 검증 + Smoke Test

## 12. 브랜치 전략 연계

- **develop**: 개발 통합 브랜치
- **test**: QA 테스트용 브랜치 (릴리즈 전)
- **main**: 프로덕션 배포 브랜치
- **feat/**: 기능 개발 브랜치
- **hotfix/**: 긴급 수정 브랜치

## 13. 네이밍 및 기록 관리

- **앱/배포 표기(Manifest/Info.plist/릴리즈 노트)**: `major.minor.patch-level+buildNumber`
  - 예) `6.3.0-rc.1+1021`
- **Git Tag**: `major.minor.patch-level` (Build Number 미포함)
  - 예) `6.3.0-rc.1`
- **Jira Version**: `major.minor.patch` (Level/Build 미포함)
  - 예) `6.3.0`
- **CI/CD 기록 원칙**: 빌드 번호는 아티팩트/릴리즈 노트/스토어 제출 정보에 기록하되, Git Tag와 Jira Version에는 포함하지 않습니다.

## 14. 릴리즈 노트 작성 가이드

- **작성 책임자**: PL(Project Lead)이 최종 검토 및 승인
- **작성 시점 및 범위**:
  - Major 버전: 필수 작성, 상세 변경 내역 포함, 사용자 공지 필수
  - Minor 버전: 필수 작성, 주요 기능 중심으로 요약
  - Patch 버전: 선택적 작성 (중요 버그 수정 시 간략히 작성)
- **포함 내용**:
  - 새로운 기능 (New Features)
  - 개선 사항 (Improvements)
  - 버그 수정 (Bug Fixes)
  - 알려진 이슈 (Known Issues, 필요 시)
  - Breaking Changes (Major 버전 시 필수)
  - Deprecation 안내 (해당 시)
- **형식**: CHANGELOG.md 파일 또는 Jira Release Notes 활용

## 15. 버전 수명주기 및 지원 정책 (앱)

이 섹션은 주로 **앱(클라이언트)**에 적용됩니다. 웹은 사용자가 항상 최신 버전을 사용하므로 별도 정책이 필요하지 않습니다.

- **앱 버전 지원 기간**:
  - 최신 Major 버전: 전체 지원 (신규 기능 추가, 버그 수정, 보안 패치)
  - 이전 Major 버전: 최소 1년간 보안 패치 및 크리티컬 버그 수정 지원
  - 2세대 이전 Major 버전: EOL(End of Life) 선언, 지원 종료
- **EOL 선언 기준**:
  - 사용자 비율 5% 미만으로 하락 시 검토
  - 새로운 Major 버전 출시 1년 후
  - 보안 또는 기술적 한계로 지원 불가능한 경우
- **구 버전 사용자 대응**:
  - EOL 3개월 전 사전 공지 (인앱 메시지, 푸시 알림)
  - 업데이트 유도 메시지 표시
  - Critical 보안 이슈 발생 시 강제 업데이트 고려
- **서버 API 호환성**:
  - 서버는 최소 2개 Major 버전의 앱과 호환성 유지 필요
  - 앱 EOL 이후에도 일정 기간 API 지원 유지

## 16. 버전 결정 권한 및 승인 프로세스

- **Major 버전**:
  - 제안: PL, 개발 책임자, 경영진
  - 승인: 경영진·기획·개발 합의 필요
  - 문서화: 개발계획서에 반드시 명시
- **Minor 버전**:
  - 제안: PL, 개발 리더
  - 승인: PL 승인 (개발 책임자 검토)
  - 문서화: Jira Epic 또는 개발 계획서 요약본
- **Patch 버전**:
  - 제안: 개발자, QA
  - 승인: PL 승인
  - 문서화: Jira 이슈 관리
- **긴급 Hotfix**:
  - 제안: 운영팀, 개발팀
  - 승인: PL 또는 개발 책임자 (긴급 시 사후 보고 가능)
  - 문서화: 사고 대응 보고서 작성

## 17. 실제 시나리오별 버전 결정 예시

| 변경 내용                                 | 버전 증가        | 예시                     |
| ----------------------------------------- | ---------------- | ------------------------ |
| 신규 서비스 출시 (예: 데이팅 서비스 추가) | Major            | 5.8.3 → 6.0.0            |
| 전면 UI/UX 개편                           | Major            | 6.5.2 → 7.0.0            |
| API Breaking Change                       | Major            | 2.9.0 → 3.0.0            |
| 신규 매칭 알고리즘 도입                   | Minor            | 6.1.5 → 6.2.0            |
| 프로필 수정 기능 추가                     | Minor            | 6.2.3 → 6.3.0            |
| 성능 개선 (로딩 속도 향상)                | Minor            | 6.3.1 → 6.4.0            |
| 로그인 버그 수정                          | Patch            | 6.4.0 → 6.4.1            |
| 텍스트 오타 수정                          | Patch            | 6.4.1 → 6.4.2            |
| 보안 패치 (긴급)                          | Patch (Hotfix)   | 6.4.2 → 6.4.3            |
| 결제 로직 크리티컬 버그 수정              | Patch (Hotfix)   | 6.4.3 → 6.4.4            |
| UI 테마 색상 변경                         | Patch            | 6.4.4 → 6.4.5            |
| 최소 지원 OS 버전 상향 (iOS 14→15)        | Minor 또는 Major | 6.4.5 → 6.5.0 또는 7.0.0 |

## 18. 모니터링 및 추적

- **버전별 사용자 분포 모니터링**:
  - 주간/월간 리포트로 버전별 사용자 비율 추적
  - EOL 결정 시 주요 지표로 활용
- **버전별 크래시/이슈 추적**:
  - Sentry, Firebase Crashlytics 등 도구 활용
  - 버전별 안정성 지표 모니터링
- **배포 이력 관리**:
  - CI/CD 파이프라인에서 자동 기록
  - 배포 날짜, 담당자, 승인자 정보 보관

## 19. 추가 권장 사항

- **릴리즈 노트 표준화**: Major/Minor 시 반드시 사용자 공지 포함
- **Feature Gate/Closed Beta 전략**: 대규모 변경 시 단계적 배포 및 롤백 대비
- **버전 체계 교육/공유**: 모든 관련자가 동일한 규칙을 이해하도록 사내 공유
- **자동화 도구 활용**: 버전 번호 자동 증가, Git Tag 자동 생성, Changelog 자동 생성 등
- **정기 회고**: 분기별로 버전 관리 프로세스 회고 및 개선

---

본 가이드는 추후 개발계획서(특히 Major 변경 정의)와 연계하여 운영하며, 실제 운영 경험에 따라 주기적으로 개선합니다.
