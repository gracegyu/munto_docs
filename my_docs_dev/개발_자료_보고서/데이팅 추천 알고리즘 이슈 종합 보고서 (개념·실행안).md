# 데이팅 추천 알고리즘 이슈 종합 보고서 (개념·실행안)

작성: 전규현

목표 독자: 개발팀

---

## 0) 근본 딜레마 정리 (수익 vs 매칭 확률)

- **문제의 본질**: 매칭 확률이 가장 높은 상대만 빠르게 노출하면 유저는 금방 짝을 찾고 서비스 이용을 멈춰 매출이 줄어듦. 반대로 매칭이 지나치게 지연되면 유저 불만과 이탈이 발생해 역시 매출 감소.
- **비즈니스 핵심**: 매출 극대화는 **“될 듯 될 듯한 매칭 경험”**을 제공해 유저가 계속 프로필을 탐색하고, 좋아요/슈퍼좋아요/친구신청/채팅 등 **유료 행위**를 지속적으로 유도하는 데 있음.
- **균형의 필요성**: 수익 최적화는 단순 매칭률 최적화와 다르며, **적정 확률·적정 속도의 균형**을 잡아야 함. 이 철학이 모든 알고리즘 설계(1단계·2단계)의 전제가 되어야 함.

---

## 1) Executive Summary

- **현 상황**: 구현된 로직은 “희망 니즈 필터(나이·지역·MBTI 등) → 랜덤 노출” 중심.
- **대표 의견 요약**: 모든 유저는 평가 점수를 가져야 하며, 점수대(높음/유사/낮음)의 적절한 비율로 상대를 추천해 유저가 지불의사를 극대화하도록 설계해야 함.
- **핵심 차이**: 현재는 *규칙·필터 중심* / 대표 의도는 *점수·수익 중심 + 규칙은 보조*.
- **권고안**: 대표 의견을 반영해 “점수 기반 + 비율 노출”을 1단계부터 도입하고, 2단계에서는 학습 기반으로 고도화.

---

## 2) 대표 의견 주요 포인트 반영

### (1) 과금 정책 이해

- 하루 2회 무료 추천(각 5명).
- 무료 좋아요, 유료 친구신청, 유료 채팅신청(단, 응답 없을 경우 환불).
- 수익은 주로 **남성 유저의 친구신청/채팅신청**에서 발생.

### (2) 알고리즘 기본 방향

- 유저 프로필은 필수 요소(나이, 사진, 지역)와 선택 요소(MBTI, 직업 등)로 평가됨.
- 추천은 단순 필터링이 아니라 **점수화된 유저 풀을 기반**으로 함.
- 추천 시 **높은 점수/유사 점수/낮은 점수** 후보를 일정 비율 섞어 노출.
- 단, 너무 높은 점수만 추천 시 거절율↑ → 이탈 위험. 너무 낮은 점수만 추천 시 불만↑ → 이탈 위험. → **균형 필요**.

### (3) 성별 전략

- 남: 과금 주체 → 노출 기회 최대화, 지속 탐색 유도.
- 여: 신규 유저 리텐션이 중요 → 초기에는 높은 점수의 남성 다수 노출.
- 필요하다면 **성별별 알고리즘** 설계. 예: 남성에게는 탐색 기회 다양성, 여성에게는 초기 긍정 경험 강화.

### (4) 초기 노출 전략

- **신규 가입 여성**: 첫 1~2주 동안 고득점 남성을 우선 노출시켜 만족도를 높이고 장기 이용 유도.
- **신규 가입 남성**: 일정 비율로 긍정적 피드백 가능성이 높은 여성에게 노출시켜 빠른 보상 경험 제공.

### (5) 데이터 기반 개선 지표

- 티어별 친구신청율 / 친구수락율 / 채팅수락율 / 과금전환율.
- 노출 대비 지불행위 발생률.
- **신규 vs 기존 유저 비교 지표**: 초기 리텐션 효과 추적.

---

## 3) 점수 체계 정의 (Desirability, Engagement, Monetization)

- **Desirability (매력도)**: 다른 유저들이 해당 프로필을 얼마나 선호하는가를 반영하는 지표. (예: 프로필 사진 퀄리티, 좋아요/슈퍼좋아요 비율, 상대방 선택 빈도)
- **Engagement (참여도)**: 해당 유저가 앱에 얼마나 적극적으로 참여하는가를 나타내는 지표. (예: 로그인 빈도, 행동 이벤트 수, 응답 속도)
- **Monetization (수익 기여도)**: 해당 유저가 직접적 혹은 간접적으로 매출에 기여하는 정도. (예: 친구신청·채팅신청 유료 전환율, 과금 패턴)

이 3가지 축을 종합해 유저 점수를 산출하고, 추천 알고리즘은 이 점수를 기반으로 상·중·하 티어를 나누어 비율 샘플링을 진행함.

---

## 4) 단계별 실행 방안

### (1단계: 전통식 알고리즘)

- 모든 유저를 점수화 (Desirability, Engagement, Monetization 3축).
- 추천 시 **비율 기반 노출 전략** 적용: 상위·유사·하위 점수대 적절히 혼합.
- 희망 니즈(지역, 나이, MBTI)는 **보조 필터**로만 적용.
- 데이터 로깅: `exposure_id` 중심으로 노출/행동/과금 이벤트 수집(DynamoDB 등).
- **성별·신규/기존 여부 태그 포함**: 향후 차등 전략 학습을 위한 데이터 확보.

### (2단계: 학습 기반 알고리즘)

- 1단계에서 수집한 데이터를 활용, 신경망 모델로 **매출 최적화형 추천** 학습.
- Input 데이터: 프로필 특징(나이, 사진 특성, MBTI 등), 사용자 행동 히스토리, 성별 구분, 신규/기존 여부.
- Output 데이터: 친구신청, 수락 여부, 채팅 요청/수락 여부, 지불 이벤트.
- 목표: **매출 기여 확률**을 직접 예측하는 모델.

---

## 5) 데이터 수집·운영 설계 (1단계→2단계)

### (1) 수집 방식

- **DynamoDB 중심**으로 실시간 이벤트 누적.
- 주요 테이블:
    - `exposures`: 노출 이벤트 저장 (user_id, candidate_id, score_tier, exposure_id, timestamp).
    - `interactions`: 행동 이벤트 저장 (exposure_id, action_type, result, timestamp).
    - `payments`: 과금 이벤트 저장 (user_id, action_type, amount, timestamp).
- `exposure_id`를 공통 키로 사용해 노출–행동–과금을 연결.

### (2) 수집 데이터 항목

- **Input Features**: 나이, 성별, 지역, MBTI, 직업, 사진 분석(품질/매력도), 활동성(로그인 빈도, 행동 횟수).
- **Context Features**: 신규/기존 여부, 시간대, 추천 위치(첫 노출/후속 노출).
- **Output Labels**:
    - LIKE / SUPERLIKE / PASS
    - FRIEND_REQ / CHAT_REQ (결제 여부 포함)
    - FRIEND_ACCEPT / CHAT_ACCEPT
- **과금 지표**: 결제 금액, 환불 여부, 결제 전환율.

### (3) 운영 고려사항

- DynamoDB Streams + Kinesis Firehose로 데이터 레이크(S3)에 적재.
- 주기적 배치 파이프라인으로 집계(예: 일 단위 점수 업데이트).
- 개인정보 보호를 위해 식별자는 해시 처리 후 저장.

---

## 6) 상세 Flow (추천 프로세스)

1. **유저 진입** → Discover/추천 탭 호출.
2. **후보군 생성**: 지역·나이·활동여부 필터.
3. **점수 기반 랭킹**: Desirability/Engagement/Monetization Score 종합으로 상·중·하 그룹 분리.
4. **비율 샘플링**: 예) 상위 20%, 유사 50%, 하위 30%.
5. **성별/신규 전략 반영**: 여성 신규라면 상위 비율 상향, 남성 신규라면 빠른 반응군 우선.
6. **최종 리스트 캐싱**: Redis에 저장, `rec:{user}:{date}` 형태.
7. **노출 이벤트 기록**: `exposure_id` 생성, DB/로그 적재.

---

## 7) DB Schema 초안

```sql
-- 유저 점수 테이블
CREATE TABLE user_scores_daily (
  user_id BIGINT PRIMARY KEY,
  desirability_score FLOAT,
  engagement_score FLOAT,
  monetization_score FLOAT,
  gender CHAR(1),
  is_new BOOLEAN,
  score_tier SMALLINT,
  calculated_at TIMESTAMP
);

-- 추천 스냅샷
CREATE TABLE rec_snapshots_daily (
  snapshot_id BIGSERIAL PRIMARY KEY,
  user_id BIGINT,
  exposure_id UUID,
  candidate_id BIGINT,
  score_tier SMALLINT,
  created_at TIMESTAMP
);

-- 행동/결제 로그
CREATE TABLE interactions (
  interaction_id BIGSERIAL PRIMARY KEY,
  exposure_id UUID,
  user_id BIGINT,
  candidate_id BIGINT,
  action_type VARCHAR(30), -- LIKE, SUPERLIKE, PASS, FRIEND_REQ, CHAT_REQ
  result BOOLEAN,
  created_at TIMESTAMP
);

```

---

## 8) API 설계 예시

- `GET /recommendations/today`
    - 응답: 후보 리스트 (user_id, score_tier, 프로필 요약, exposure_id)
- `POST /interactions`
    - 요청: {exposure_id, action_type, result}
    - 응답: success 여부

---

## 9) 캐시 및 TTL 전략

- Redis Key: `rec:{user_id}:{date}`
- TTL: 24시간 (하루 2회 무료 추천 분량 관리)
- 무효화 규칙: 유저 상태 변경(탈퇴, 차단, 비활성화) 시 즉시 삭제

---

## 10) 성능 및 모니터링

- **응답 시간 목표**: 추천 API 300ms 이내 (캐시 활용 기준).
- **모니터링 지표**:
    - 노출 수 대비 상호작용 비율
    - 티어별 지불행위 전환율
    - 신규/기존 유저별 리텐션 곡선

---

## 11) 결론

- 대표 의견(점수 기반 + 비율 추천)을 수익 극대화 철학과 접목해 **단계별 알고리즘 로드맵**을 확정.
- Desirability, Engagement, Monetization 세 축을 활용한 점수화 체계를 통해 매칭 경험과 매출을 동시에 최적화할 수 있음.
- 이 과정을 통해 매칭 경험을 유도하면서도 매출 최적화 목표를 달성할 수 있음.